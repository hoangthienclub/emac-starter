#+TITLE: thientran's GNU Emacs Config
#+AUTHOR: Thien Tran
#+DESCRIPTION: thientran's personal Emacs config.
#+STARTUP: showeverything
#+OPTIONS: toc:2

* TABLE OF CONTENTS :toc:
- [[#package-management][Package Management]]
  - [[#repositories][Repositories]]
  - [[#adding-the-scripts-directory-to-path][Adding the scripts directory to path]]
  - [[#sourcing-the-scripts][Sourcing the scripts]]
- [[#basic-configuration][Basic Configuration]]
  - [[#early-init][Early Init]]
  - [[#emacs-behavior][Emacs Behavior]]
- [[#graphical-user-interface-tweaks][Graphical User Interface Tweaks]]
  - [[#theme][Theme]]
  - [[#font][Font]]
  - [[#dashboard][Dashboard]]
  - [[#rainbow-mode][Rainbow Mode]]
  - [[#rainbow-delimiters][Rainbow Delimiters]]
  - [[#yall-want-some-more-colors][Y’all want some more COLORS?]]
- [[#evil][Evil]]
  - [[#basic][Basic]]
  - [[#evil-define-keys][Evil Define Keys]]
- [[#org-mode][Org-mode]]
  - [[#basic-config][Basic Config]]
  - [[#configuration-babel-languages][Configuration Babel Languages]]
  - [[#structure-template][Structure Template]]
  - [[#auto-tangle-configuration-files][Auto-tangle Configuration Files]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#disable-electric-indent][Disable Electric Indent]]
- [[#general-keybindings][General Keybindings]]
  - [[#which-key][Which Key]]
  - [[#keybindings][Keybindings]]
- [[#packages-configuration][Packages Configuration]]
  - [[#code-autocompletion][Code Autocompletion]]
  - [[#ivy][Ivy]]
  - [[#counsel][Counsel]]
  - [[#dired][Dired]]
  - [[#projectile][Projectile]]
  - [[#neotree][Neotree]]
  - [[#avy][Avy]]
  - [[#yasnippet][Yasnippet]]
- [[#programing][Programing]]
  - [[#fringe][Fringe]]
  - [[#treesister][Treesister]]
  - [[#databases][Databases]]
  - [[#flycheck][Flycheck]]
  - [[#spellcheck][Spellcheck]]
  - [[#lsp-mode][LSP Mode]]
  - [[#nginx][Nginx]]
  - [[#csv][CSV]]
  - [[#json][JSON]]
- [[#general-programming-languages][General Programming Languages]]
  - [[#web-programming][Web programming]]
  - [[#css][CSS]]
  - [[#javascript][Javascript]]
  - [[#typescript][Typescript]]
  - [[#golang][Golang]]
- [[#others][Others]]
  - [[#beauty-json][Beauty Json]]
  - [[#protobuf][Protobuf]]

* Package Management
** Repositories
#+begin_src emacs-lisp
(setq debug-on-error t)
;; Initialize package sources
(setq package-archives '(("melpa"  . "https://melpa.org/packages/")
                    ("gnu"    . "https://elpa.gnu.org/packages/")
                    ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
#+end_src
** Adding the scripts directory to path
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/scripts/")
#+end_src

** Sourcing the scripts
#+begin_src emacs-lisp
(require 'straight-setup) ;; The Straight Package Manager
(require 'buffer-move) ;; Buffer-move for better window management
(setq straight-vc-git-default-remote-name "straight")
#+end_src

Now, we can refresh our package list in order to be able to install stuff.
#+begin_src emacs-lisp
(package-initialize)
(unless package-archive-contents
    (package-refresh-contents))

(setq straight-vc-git-default-remote-name "straight")
#+end_src
We finally come to the use-package installation. This is done like so:
#+begin_src emacs-lisp
(straight-use-package '(use-package :build t))
(setq use-package-always-ensure t)
#+end_src

* Basic Configuration
** Early Init
The early init file is the file loaded before anything else in Emacs. This is where I put some options in order to disable as quickly as possible some built-in features of Emacs before they can be even loaded, speeding Emacs up a bit.
#+begin_src emacs-lisp #+begin_src emacs-lisp :mkdirp yes :tangle ~/.emacs.d/early-init.el :export code :results silent :lexical t

;; NOTE: Setting `font-lock-multiline' to 'undecided' org-mode to become unusable:
;; Error during redisplay: (jit-lock-function 22138) signaled (args-out-of-range 0 16341)
(setq-default font-lock-multiline nil)

;;; Better defaults
(set-language-environment "UTF-8")
(setq default-input-method nil)

;; better simple ui
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
(blink-cursor-mode 0)

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(fullscreen . maximized) default-frame-alist)
(push '(ns-use-native-fullscreen . t) default-frame-alist)
(push '(ns-transparent-titlebar . t) default-frame-alist)
(push '(vertical-scroll-bars . nil) default-frame-alist)


(setq visible-bell nil ;; set to non-nil to flash!
      ring-bell-function 'ignore
      large-file-warning-threshold (* 50 1024 1024) ;; change to 50 MiB
      use-short-answers t ;; y or n istead of yes or no
      confirm-kill-emacs 'y-or-n-p ;; confirm before quitting
      inhibit-startup-message t
      delete-by-moving-to-trash t)

(customize-set-variable 'native-comp-async-report-warnings-errors nil)
(customize-set-variable 'native-comp-speed 3)
(customize-set-variable 'native-comp-deferred-compilation nil)

 (setq frame-inhibit-implied-resize t
      frame-resize-pixelwise t
      frame-title-format nil
      truncate-lines t
      truncate-partial-width-windows t
      package-enable-at-startup nil
      indicate-buffer-boundaries '((bottom . right))
      inhibit-splash-screen t
      inhibit-startup-buffer-menu t
      inhibit-startup-message t
      inhibit-startup-screen t
      inhibit-compacting-font-caches t
      initial-scratch-message nil
      load-prefer-newer noninteractive
      site-run-file nil)

;; (setq debug-on-error t)

;;; Undo
(setq undo-limit        10000000 ;; 1MB (default is 160kB)
      undo-strong-limit 100000000 ;; 100MB (default is 240kB)
      undo-outer-limit  1000000000) ;; 1GB (default is 24MB)

;;; Editing
(setq display-line-numbers-type 'relative
      tab-always-indent nil
      whitespace-action '(cleanup auto-cleanup))

(setq-default fill-column 140
              indent-tabs-mode nil
              display-line-numbers-width 3
              tab-width 2)

;;; Backups
;; Disable backup and lockfiles
(setq create-lockfiles nil
      make-backup-files nil
      version-control t ;; number each backup file
      backup-by-copying t ;; copy instead of renaming current file
      delete-old-versions t ;; clean up after itself
      kept-old-versions 5
      kept-new-versions 5
      tramp-backup-directory-alist backup-directory-alist)

;;; Auto-Saving, sessions...
;; Enable auto-save (use `recover-file' or `recover-session' to recover)
(setq auto-save-default t
      auto-save-include-big-deletions t
      auto-save-file-name-transforms
      (list (list "\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'"
                  ;; Prefix tramp autosaves to prevent conflicts with local ones
                  (concat auto-save-list-file-prefix "tramp-\\2") t)
            (list ".*" auto-save-list-file-prefix t)))

;;; Scrolling
(setq hscroll-step 2
      hscroll-margin 5
      scroll-step 2
      scroll-margin 5
      scroll-conservatively 101
      scroll-preserve-screen-position 'always
      auto-window-vscroll nil
      fast-but-imprecise-scrolling t)

(setq-default scroll-up-aggressively 0.01
              scroll-down-aggressively 0.01)

(setq window-combination-resize t)

(setq recentf-max-saved-items 100)

;;; Enable global modes
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
(add-hook 'prog-mode-hook #'hs-minor-mode)

;; Scroll pixel by pixel
(pixel-scroll-mode 1)

;; Window layout undo/redo (`winner-undo' / `winner-redo')
(winner-mode 1)

;; Highlight current line
(global-hl-line-mode 1)

;; Enable recentf-mode globally
(recentf-mode 1)

;; Save place in files
(save-place-mode 1)

;; Enable saving minibuffer history
(savehist-mode 1)

;; Show line and column numbers (cursor position) in mode-line
(line-number-mode 1)

;; Wrap long lines
(global-visual-line-mode 1)

;; Better handling for files with so long lines
(global-so-long-mode 1)

;; Global SubWord mode
(global-subword-mode 1)

;; Set Fullscreen
;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

;; ;; Set Transparency
;; (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
;; (add-to-list 'default-frame-alist '(alpha . (100 . 100)))

#+end_src
** Emacs Behavior
*** Editing Text in Emacs
Editing Text in Emacs
I never want to keep trailing spaces in my files, which is why I’m doing this:
#+begin_src emacs-lisp

(add-hook 'before-save-hook #'whitespace-cleanup)
(server-start)

#+end_src
I don’t understand why some people add two spaces behind a full stop, I sure don’t. Let’s tell Emacs.
#+end_src
I never want to keep trailing spaces in my files, which is why I’m doing this:
#+begin_src emacs-lisp

(setq-default sentence-end-double-space nil)

#+end_src
Lastly, I want the default mode for Emacs to be Emacs Lisp.
#+begin_src emacs-lisp

(setq-default initial-major-mode 'emacs-lisp-mode)

#+end_src
Default tab width
#+begin_src emacs-lisp

(setq-default tab-width 2)

#+end_src
*** Stay Clean, Emacs!
It also loves to litter its ~init.el~ with custom variables here and there, but the thing is: I regenerate my ~init.el~ each time I tangle this file! How can I keep Emacs from adding stuff that will be almost immediately lost? Did someone say /custom file/?
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file) ; Don’t forget to load it, we still need it
  (load custom-file))
#+end_src

*** Stay Polite, Emacs!
When asking for our opinion on something, Emacs loves asking us to answer by “yes” or “no”, but *in full*! That’s very rude! Fortunately, we can fix this.
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

This will make Emacs ask us for either hitting the ~y~ key for “yes”, or the ~n~ key for “no”. Much more polite!

It is also very impolite to keep a certain version of a file in its buffer when said file has changed on disk. Let’s change this behavior:
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

Much more polite! Note that if the buffer is modified and its changes haven’t been saved, it will not automatically revert the buffer and your unsaved changes won’t be lost. Very polite!

* Graphical User Interface Tweaks
** Theme
You may have noticed I use the Nord theme pretty much everywhere on my computer, why not Emacs? In my opinion, its aurora variant is nicer than the default Nord theme since it is richer in colors — just a personal preference.
#+begin_src emacs-lisp

(unless (package-installed-p 'autothemer)
  (package-refresh-contents)
  (package-install 'autothemer))

(add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes/"))

(use-package doom-themes
  :straight (:build t)
  :ensure t
  :config
  ;; (load-theme 'catppuccin-latte t)
  ;; (load-theme 'catppuccin-frappe t)
  (load-theme 'catppuccin-macchiato t)
  ;; (load-theme 'catppuccin-mocha t)
  ;; (load-theme 'rose-pine t)
  ;; (load-theme 'oxocarbon t)
  ;; (load-theme 'kman t)
  ;; (load-theme 'kanagawa t)
  ;; (load-theme 'doom-tokyo-night t)
  (doom-themes-neotree-config)
  (doom-themes-org-config))
#+end_src

** Font
*** Set The Font
#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :font "JetBrains Mono"
                      ;; :font "Victor Mono"
                      :weight 'regular
                      :height 135)

  ;;Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      ;; :font "Victor Mono"
                      :weight 'regular
                      :height 135)

  ;;Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      ;; :font "Victor Mono"
                      ;; :font "Cantarell"
                      :font "Victor Mono"
                      :height 135
                      :weight 'light)
#+end_src

*** Emojis
#+begin_src emacs-lisp
  ;;(set-fontset-font t 'symbol "Noto Color Emoji")
  ;;(set-fontset-font t 'symbol "Symbola" nil 'append)

  (use-package emojify
    :straight (:build t)
    :custom
    (emojify-emoji-set "emojione-v2.2.6")
    (emojify-emojis-dir (concat user-emacs-directory "emojify/"))
    (emojify-display-style 'image)
    (emojify-download-emojis-p t)
    :config
    (global-emojify-mode 1))
#+end_src

** Dashboard
Emacs Dashboard is an extensible startup screen showing you recent files, bookmarks, agenda items and an Emacs banner.
#+begin_src emacs-lisp
(use-package dashboard
  :ensure t
  :init
  (setq initial-buffer-choice 'dashboard-open)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-banner-logo-title "Emacs Is More Than A Text Editor!")
  ;;(setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
  (setq dashboard-startup-banner "/Users/tranthien/.emacs.d/images/dtmacs-logo.png")  ;; use custom image as banner
  (setq dashboard-center-content nil) ;; set to 't' for centered content
  (setq dashboard-items '((recents . 5)
                          (agenda . 5 )
                          (bookmarks . 3)
                          (projects . 3)
                          (registers . 3)))
  :custom
  (dashboard-modify-heading-icons '((recents . "file-text")
              (bookmarks . "book")))
  :config
  (dashboard-setup-startup-hook))
#+end_src
** Rainbow Mode
Display the actual color as a background for any hex color value (ex. #ffffff).  The code block below enables rainbow-mode in all programming modes (prog-mode) as well as org-mode, which is why rainbow works in this document.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish
  :hook org-mode prog-mode)
#+end_src

** Rainbow Delimiters
This makes Lisp especially more readable, but it’s also nice to have for any language that has delimiters like brackets too.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :straight (:build t)
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Y’all want some more COLORS?
It is possible to make info buffers much more colorful (and imo easier to read) with this simple package:
#+begin_src emacs-lisp
(use-package info-colors
  :straight (:build t)
  :commands info-colors-fnontify-node
  :hook (Info-selection . info-colors-fontify-node)
  :hook (Info-mode      . mixed-pitch-mode))
#+end_src
* Evil
Evil is an extensible vi/vim layer for Emacs.  Because…let’s face it.  The Vim keybindings are just plain better.
** Basic
#+begin_src emacs-lisp
(use-package evil
    :init      ;; tweak evil's configuration before loading it
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-want-C-u-scroll t
          evil-want-C-i-jump nil
          evil-undo-system 'undo-redo)  ;; Adds vim-like C-r redo functionality
    (evil-mode))
  (use-package evil-collection
    :after evil
    :config
    (setq evil-collection-mode-list '(dashboard dired ibuffer))
    (evil-collection-init))
  (use-package evil-tutor)
#+end_src
** Evil Define Keys
#+begin_src emacs-lisp
(evil-global-set-key 'motion "j" 'evil-next-visual-line)
(evil-global-set-key 'motion "k" 'evil-previous-visual-line)
(evil-global-set-key 'motion "w" 'evil-avy-goto-word-1)
#+end_src

* Org-mode
** Basic Config
#+begin_src emacs-lisp

(defun efs/org-mode-setup ()
  (org-indent-mode)
  (variable-pitch-mode 1)
  (visual-line-mode 1))

;; Org Mode Configuration ------------------------------------------------------

(defun efs/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Source Code Pro" :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))


(use-package org
  :hook (org-mode . efs/org-mode-setup)
  :config
  (setq org-ellipsis " ▾")
  (efs/org-font-setup))

(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

(defun efs/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . efs/org-mode-visual-fill))

#+end_src
** Configuration Babel Languages

#+begin_src emacs-lisp

(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (python . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src

** Structure Template

#+begin_src emacs-lisp

(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Auto-tangle Configuration Files

#+begin_src emacs-lisp

  ;; Automatically tangle our Emacs.org config file when we save it
  (defun efs/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "/Users/tranthien/.emacs.d/Emacs.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))

#+end_src
** Enabling Table of Contents
#+begin_src emacs-lisp
(use-package toc-org
    :commands toc-org-enable
    :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src
** Disable Electric Indent
Org mode source blocks have some really weird and annoying default indentation behavior.  I think this has to do with electric-indent-mode, which is turned on by default in Emacs, and the fact that Org defaults to indenting 2 spaces in source blocks.  So let's turn it all of that OFF!

#+begin_src emacs-lisp
(electric-indent-mode -1)
(setq org-edit-src-content-indentation 0)
#+end_src

* General Keybindings
** Which Key
#+begin_src emacs-lisp
  (use-package which-key
    :straight (:build t)
    :defer t
    :init
      (which-key-mode 1)
    :diminish
    :config
    (setq which-key-side-window-location 'bottom
      which-key-sort-order #'which-key-key-order-alpha
      which-key-allow-imprecise-window-fit nil
      which-key-sort-uppercase-first nil
      which-key-add-column-padding 1
      which-key-max-display-columns nil
      which-key-min-display-lines 6
      which-key-side-window-slot -10
      which-key-side-window-max-height 0.25
      which-key-idle-delay 0.8
      which-key-max-description-length 25
      which-key-allow-imprecise-window-fit nil
      which-key-separator " → " ))

  (use-package which-key-posframe
    :ensure t
    :config
    (which-key-posframe-mode))
#+end_src
** Keybindings
#+begin_src emacs-lisp
  (use-package general
    :straight (:build t)
    :init

    (general-auto-unbind-keys)
    :config
    (general-evil-setup)

    ;; set up 'SPC' as the global leader key
    (general-create-definer dqv/leader-key
        :states '(normal insert visual emacs)
        :keymaps 'override
        :prefix "SPC" ;; set leade
        :global-prefix "M-SPC")
    (general-create-definer dqv/evil
        :states '(normal)) ;; access leader in insert mode
    (general-create-definer dqv/major-leader-key
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix ","
      :global-prefix "M-m"))

    (dqv/leader-key
        "SPC" '(counsel-M-x :wk "Counsel M-x")
        "." '(find-file :wk "Find file")
        "f c" '((lambda () (interactive) (find-file "~/.emacs.d/config.org")) :wk "Edit emacs config")
        "f r" '(counsel-recentf :wk "Find recent files")
        "TAB TAB" '(comment-line :wk "Comment lines"))

    (dqv/leader-key
        "d" '(:ignore t :wk "Dired")
        "d d" '(dired :wk "Open dired")
        "d j" '(dired-jump :wk "Dired jump to current")
        "d n" '(neotree-dir :wk "Open directory in neotree")
        "d p" '(peep-dired :wk "Peep-dired"))


    (dqv/leader-key
      "b" '(:ignore t :wk "Bookmarks/Buffers")
      "b c" '(clone-indirect-buffer :wk "Create indirect buffer copy in a split")
      "b C" '(clone-indirect-buffer-other-window :wk "Clone indirect buffer in new window")
      "b d" '(bookmark-delete :wk "Delete bookmark")
      "b i" '(ibuffer :wk "Ibuffer")
      "b k" '(kill-this-buffer :wk "Kill this buffer")
      "b K" '(kill-some-buffers :wk "Kill multiple buffers")
      "b l" '(list-bookmarks :wk "List bookmarks")
      "b m" '(bookmark-set :wk "Set bookmark")
      "b n" '(next-buffer :wk "Next buffer")
      "b p" '(previous-buffer :wk "Previous buffer")
      "b r" '(revert-buffer :wk "Reload buffer")
      "b R" '(rename-buffer :wk "Rename buffer")
      "b s" '(basic-save-buffer :wk "Save buffer")
      "b S" '(save-some-buffers :wk "Save multiple buffers")
      "b w" '(bookmark-save :wk "Save current bookmarks to bookmark file"))

    (dqv/leader-key
      "t" '(:ignore t :wk "Toggle")
      "t e" '(eshell-toggle :wk "Toggle eshell")
      "t f" '(flycheck-mode :wk "Toggle flycheck")
      "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
      "t n" '(neotree-toggle :wk "Toggle neotree file viewer")
      "t r" '(rainbow-mode :wk "Toggle rainbow mode")
      "t t" '(visual-line-mode :wk "Toggle truncated lines")
      "t v" '(vterm-toggle :wk "Toggle vterm"))

    (dqv/leader-key
        "h r" '(:ignore t :wk "Reload")
        "h t" '(load-theme :wk "Load theme")
        "h r r" '((lambda () (interactive)
                    (load-file "~/.emacs.d/init.el")
                    (ignore (elpaca-process-queues)))
                :wk "Reload emacs config"))

    (dqv/leader-key
      "w" '(:ignore t :wk "Windows")
      ;; Window splits
      "w c" '(evil-window-delete :wk "Close window")
      "w n" '(evil-window-new :wk "New window")
      "w s" '(evil-window-split :wk "Horizontal split window")
      "w v" '(evil-window-vsplit :wk "Vertical split window")
      ;; Window motions
      "w h" '(evil-window-left :wk "Window left")
      "w j" '(evil-window-down :wk "Window down")
      "w k" '(evil-window-up :wk "Window up")
      "w l" '(evil-window-right :wk "Window right")
      "w w" '(evil-window-next :wk "Goto next window")
      ;; Move Windows
      "w H" '(buf-move-left :wk "Buffer move left")
      "w J" '(buf-move-down :wk "Buffer move down")
      "w K" '(buf-move-up :wk "Buffer move up")
      "w L" '(buf-move-right :wk "Buffer move right"))

    (dqv/leader-key
        "s" '(:ignore t :wk "Search")
        "s f" '(swiper :wk "Search File"))
#+end_src

* Packages Configuration
** Code Autocompletion
Company is, in my opinion, the best autocompleting engine for Emacs, and it is one of the most popular if not the most popular.
#+begin_src emacs-lisp
(use-package company
  :straight (:build t)
  :defer t
  :hook (company-mode . evil-normalize-keymaps)
  :init (global-company-mode)
  :config
  (setq company-minimum-prefix-length     2
        company-toolsip-limit             14
        company-idle-delay                0.2
        company-tooltip-align-annotations t
        company-require-match             'never
        company-global-modes              '(not erc-mode message-mode help-mode gud-mode)
        company-frontends
        '(company-pseudo-tooltip-frontend ; always show candidates in overlay tooltip
          company-echo-metadata-frontend) ; show selected candidate docs in echo area
        company-backends '(company-capf)
        company-auto-commit         nil
        company-auto-complete-chars nil
        company-dabbrev-other-buffers nil
        company-dabbrev-ignore-case nil
        company-dabbrev-downcase    nil))
#+end_src

** Ivy
My main menu package is ivy which I use as much as possible –I’ve noticed helm can be slow, very slow in comparison to ivy so I’ll use the latter as much as possible. Actually, only ivy is installed for now. I could have used ido too, but I find it to be a bit too restricted in terms of features compared to ivy.
#+begin_src emacs-lisp
  (use-package ivy
    :straight t
    :defer t
    :diminish
    :bind (("C-s" . swiper))
    :custom
        (setq ivy-use-virtual-buffers t)
        (setq ivy-count-format "(%d/%d) ")
        (setq enable-recursive-minibuffers t)
    :config
    (ivy-mode 1)
    (setq ivy-wrap                        t
          ivy-height                      17
          ivy-sort-max-size               50000
          ivy-fixed-height-minibuffer     t
          ivy-read-action-functions       #'ivy-hydra-read-action
          ivy-read-action-format-function #'ivy-read-action-format-columns
          projectile-completion-system    'ivy
          ivy-on-del-error-function       #'ignore
          ivy-use-selectable-prompt       t))
#+end_src

There is also ~prescient.el~ that offers some nice features when coupled with ivy, guess what was born out of it? ivy-prescient, of course!
#+begin_src emacs-lisp
(use-package ivy-prescient
  :after ivy
  :straight (:build t))
#+end_src

I warned you I’d use too much all-the-icons, I did!
#+begin_src emacs-lisp
(use-package all-the-icons-ivy
  :straight (:build t)
  :after (ivy all-the-icons)
  :hook (after-init . all-the-icons-ivy-setup))
#+end_src

A buffer popping at the bottom of the screen is nice and all, but have you considered a floating buffer in the center of your frame?
#+begin_src emacs-lisp
(use-package ivy-posframe
  :defer t
  :after (:any ivy helpful)
  :hook (ivy-mode . ivy-posframe-mode)
  :straight (:build t)
  :init
  (ivy-posframe-mode 1)
  :config
  (setq ivy-fixed-height-minibuffer nil
        ivy-posframe-border-width   10
        ivy-posframe-parameters
        `((min-width  . 90)
          (min-height . ,ivy-height))))
#+end_src

Finally, let’s make ivy richer:
#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))

  (use-package ivy-rich
    :after ivy
    :after counsel
    :ensure t
    :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
    :custom
    (ivy-virtual-abbreviate 'full
     ivy-rich-switch-buffer-align-virtual-buffer t
     ivy-rich-path-style 'abbrev)
    :config
    (ivy-set-display-transformer 'ivy-switch-buffer
                                 'ivy-rich-switch-buffer-transformer))
#+end_src
** Counsel
I could almost merge this chapter with the previous one since counsel is a package that provides loads of completion functions for ivy. The ones I find most useful are counsel-M-x and counsel-find-file.
#+begin_src emacs-lisp
  (use-package counsel
    :straight (:build t)
    :after ivy
    :diminish
    :config (counsel-mode))
#+end_src

** Dired
#+begin_src emacs-lisp
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "sxiv")
                                ("jpg" . "sxiv")
                                ("png" . "sxiv")
                                ("mkv" . "mpv")
                                ("mp4" . "mpv"))))

(use-package peep-dired
  :after dired
  :hook (evil-normalize-keymaps . peep-dired-hook)
  :config
    (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
    (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file) ; use dired-find-file instead if not using dired-open package
    (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file)
    (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
)

(use-package all-the-icons
  :ensure t
  :if (display-graphic-p))

(use-package all-the-icons-dired
  :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))
#+end_src

#+end_src

** Projectile
#+begin_src emacs-lisp
(use-package projectile
  :straight (:build t)
  :diminish projectile-mode
  :custom ((projectile-completion-system 'ivy))
  :init
  (setq projectile-switch-project-action #'projectile-dired)
  :config
  (projectile-mode)
  (add-to-list 'projectile-ignored-projects "~/")
  (add-to-list 'projectile-globally-ignored-directories "^node_modules$"))
 #+end_src

** Neotree
Neotree is a file tree viewer.  When you open neotree, it jumps to the current file thanks to neo-smart-open.  The neo-window-fixed-size setting makes the neotree width be adjustable.  NeoTree provides following themes: classic, ascii, arrow, icons, and nerd.  Theme can be config'd by setting "two" themes for neo-theme: one for the GUI and one for the terminal.  I like to use 'SPC t' for 'toggle' keybindings, so I have used 'SPC t n' for toggle-neotree.
| COMMAND        | DESCRIPTION               | KEYBINDING |
|----------------+---------------------------+------------|
| neotree-toggle | /Toggle neotree/            | SPC t n    |
| neotree- dir   | /Open directory in neotree/ | SPC d n    |

#+begin_src emacs-lisp
(use-package neotree
  :config
  (setq neo-smart-open t
        neo-show-hidden-files t
        neo-window-width 55
        neo-window-fixed-size nil
        inhibit-compacting-font-caches t
        projectile-switch-project-action 'neotree-projectile-action)
        ;; truncate long file names in neotree
        (add-hook 'neo-after-create-hook
           #'(lambda (_)
               (with-current-buffer (get-buffer neo-buffer-name)
                 (setq truncate-lines t)
                 (setq word-wrap nil)
                 (make-local-variable 'auto-hscroll-mode)
                 (setq auto-hscroll-mode nil)))))

#+end_src

#+end_src

** Avy
avy is a really convenient way of jumping around and performing actions on these selections, but I’ll need some configuration to make it eamon-compatible.
#+begin_src emacs-lisp
(use-package avy
  :defer t
  :straight t
  :config
  (setq avy-keys           '(?a ?u ?i ?e ?c ?t ?s ?r ?n)
         avy-dispatch-alist '((?x . avy-action-kill-move)
                              (?X . avy-action-kill-stay)
                              (?T . avy-action-teleport)
                              (?m . avy-action-mark)
                              (?C . avy-action-copy)
                              (?y . avy-action-yank)
                              (?Y . avy-action-yank-line)
                              (?I . avy-action-ispell)
                              (?z . avy-action-zap-to-char)))
    :general
    (dqv/evil
        :pakages 'avy
        "gc" #'evil-avy-goto-char-timer
        "gl" #'evil-avy-goto-line))
#+end_src
** Yasnippet
Yasnippet allows you to insert some pre-made code by just typing a few characters. It can even generate some string with Elisp expressions and ask the user for some input in some precise places.
#+begin_src emacs-lisp
(use-package yasnippet
  :defer t
  :straight (:build t)
  :init
  (yas-global-mode)
  :hook ((prog-mode . yas-minor-mode)
         (text-mode . yas-minor-mode)))
#+end_src

Of course, yasnippet wouldn’t be as awesome as it is without premade snippets.
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

Similarly, yatemplate offers premade files rather than just strings. That’s still yasnippet by the way.
#+begin_src emacs-lisp
(use-package yatemplate
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

And finally, with ivy you can chose your snippets from a menu if you’re not sure or if you don’t remember what your snippet is.
#+begin_src emacs-lisp
(use-package ivy-yasnippet
  :defer t
  :after (ivy yasnippet)
  :straight (:build t)
  :general
  (dqv/leader-key
    :infix "i"
    :packages 'ivy-yasnippet
    "y" #'ivy-yasnippet))
#+end_src
* Programing
** Fringe
It’s nice to know which lines were modified since the last commit in a file.
#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :straight (:build t)
  :hook ((prog-mode     . git-gutter-mode)
         (org-mode      . git-gutter-mode)
         (markdown-mode . git-gutter-mode)
         (latex-mode    . git-gutter-mode))
  :config
  (setq git-gutter:update-interval 2)
  ;; These characters are used in terminal mode
  (setq git-gutter:modified-sign "≡")
  (setq git-gutter:added-sign "≡")
  (setq git-gutter:deleted-sign "≡")
  (set-face-foreground 'git-gutter:added "LightGreen")
  (set-face-foreground 'git-gutter:modified "LightGoldenrod")
  (set-face-foreground 'git-gutter:deleted "LightCoral"))
#+end_src

** Treesister
Tree sitter is a package for emacs based on ~tree-sitter~ which provides a very fast and flexible way of performing code-highlighting in Emacs.

#+begin_src emacs-lisp
(use-package tsc
  :straight (:build t))
(use-package tree-sitter
  :defer t
  :straight (:build t)
  :init (global-tree-sitter-mode))
(use-package tree-sitter-langs
  :defer t
  :after tree-sitter
  :straight (:build t))
#+end_src
** Databases
A really cool tool in Emacs for manipulating databases is emacsql. It’s able to manipulate Sqlite databases by default, but it’s also possible to manipulate MariaDB and PostgreSQL databases by installing additional packages. For now, I just need Sqlite and PostgreSQL interfaces, so let’s install the relevant packages.

#+begin_src emacs-lisp
(use-package emacsql-psql
  :defer t
  :after (emacsql)
  :straight (:build t))

(with-eval-after-load 'emacsql
  (dqv/major-leader-key
    :keymaps 'emacs-lisp-mode-map
    :packages '(emacsql)
    "E" #'emacsql-fix-vector-indentation))
#+end_src

** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :straight (:build t)
  :defer t
  :init
  (global-flycheck-mode)
  :config
  (setq flycheck-emacs-lisp-load-path 'inherit)

  ;; Rerunning checks on every newline is a mote excessive.
  (delq 'new-line flycheck-check-syntax-automatically)
  ;; And don’t recheck on idle as often
  (setq flycheck-idle-change-delay 2.0)

  ;; For the above functionality, check syntax in a buffer that you
  ;; switched to on briefly. This allows “refreshing” the syntax check
  ;; state for several buffers quickly after e.g. changing a config
  ;; file.
  (setq flycheck-buffer-switch-check-intermediate-buffers t)

  ;; Display errors a little quicker (default is 0.9s)
  (setq flycheck-display-errors-delay 0.2))
#+end_src
** Spellcheck
#+begin_src emacs-lisp
(use-package ispell
  :if (executable-find "aspell")
  :defer t
  :straight (:type built-in)
  :config
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
  (setq ispell-program-name "aspell"
        ispell-extra-args   '("--sug-mode=ultra" "--run-together")
        ispell-aspell-dict-dir (ispell-get-aspell-config-value "dict-dir")
        ispell-aspell-data-dir (ispell-get-aspell-config-value "data-dir")
        ispell-personal-dictionary (expand-file-name (concat "ispell/" ispell-dictionary ".pws")
                                                     user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell-correct
  :defer t
  :straight (:build t)
  :general ([remap ispell-word] #'flyspell-correct-at-point)
  :config
  (require 'flyspell-correct-ivy nil t))

(use-package flyspell-correct-ivy
  :defer t
  :straight (:build t)
  :after flyspell-correct)
#+end_src

#+begin_src emacs-lisp
(use-package flyspell-lazy
  :defer t
  :straight (:build t)
  :after flyspell
  :config
  (setq flyspell-lazy-idle-seconds 1
        flyspell-lazy-window-idle-seconds 3)
  (flyspell-lazy-mode +1))
#+end_src

** LSP Mode
~lsp-mode~ is a mode for Emacs which implements the Language Server Protocol and offers Emacs an IDE-like experience. In short, it’s awesome!

#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :straight (:build t)
  :init
  (setq lsp-keymap-prefix "C-c l")
  :hook ((c-mode          . lsp-deferred)
         (c++-mode        . lsp-deferred)
         (html-mode       . lsp-deferred)
         (sh-mode         . lsp-deferred)
         (rustic-mode     . lsp-deferred)
         (go-mode         . lsp-deferred)
         ;; (text-mode       . lsp-deferred)
         (move-mode       . lsp-deferred)
         (toml-mode       . lsp-deferred)
         (sql-mode       . lsp-deferred)
         (json-mode       . lsp-deferred)
         (typescript-mode . lsp-deferred)
         (lsp-mode        . lsp-enable-which-key-integration)
         (lsp-mode        . lsp-ui-mode))
  :commands (lsp lsp-deferred)
  :custom
  (lsp-idle-delay 0.6)
  (lsp-use-plist t)
  :config
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-tramp-connection "shellcheck")
                    :major-modes '(sh-mode)
                    :remote? t
                    :server-id 'shellcheck-remote)))

(setq lsp-sqls-workspace-config-path nil)
(setq lsp-enable-indentation nil)
#+end_src

I also want all the visual enhancements LSP can provide.
#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp
  :defer t
  :straight (:build t)
  :commands lsp-ui-mode
  :custom
  (lsp-ui-peek-always-show nil)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable nil))
#+end_src

#+begin_src emacs-lisp
(defun dqv/lsp-workspace-remove-missing-projects ()
  (interactive)
  (dolist (dead-project (seq-filter (lambda (x) (not (file-directory-p x))) (lsp-session-folders (lsp-session))))
    (lsp-workspace-folders-remove dead-project)))
#+end_src
And let’s enable some intergration with ivy.

#+begin_src emacs-lisp
(use-package lsp-ivy
  :straight (:build t)
  :defer t
  :after lsp
  :commands lsp-ivy-workspace-symbol)
#+end_src

#+begin_src emacs-lisp
(defun my-lsp-with-neotree ()
  (interactive)
  (neotree-toggle)
  (lsp))
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :defer t
  :straight (:build t)
  :init (exec-path-from-shell-initialize))
#+end_src

#+begin_src emacs-lisp
(use-package consult-lsp
  :defer t
  :after lsp
  :straight (:build t)
  :general
  (dqv/evil
    :keymaps 'lsp-mode-map
    [remap xref-find-apropos] #'consult-lsp-symbols))
#+end_src

** Nginx
Nginx is another webserver, older and more mature than Caddy. A couple of packages are required in order to be able to properly work with Nginx configuration files. First, we need the correct mode for editing Nginx configuration files.
#+begin_src emacs-lisp
(use-package nginx-mode
  :straight (:build t)
  :defer t)
#+end_src
We then also have an autocompletion package that adds to company the Nginx syntax.
#+begin_src emacs-lisp
(use-package company-nginx
  :straight (company-nginx :build t
                           :type git
                           :host github
                           :repo "emacsmirror/company-nginx")
  :defer t
  :config
  (add-hook 'nginx-mode-hook (lambda ()
                               (add-to-list 'company-backends #'company-nginx))))
#+end_src
** CSV
#+begin_src emacs-lisp
(use-package csv-mode
  :straight (:build t)
  :defer t
  :general
  (dqv/major-leader-key
    :keymaps 'csv-mode-map
    "a"  #'csv-align-fields
    "d"  #'csv-kill-fields
    "h"  #'csv-header-line
    "i"  #'csv-toggle-invisibility
    "n"  #'csv-forward-field
    "p"  #'csv-backward-field
    "r"  #'csv-reverse-region
    "s"  '(:ignore t :which-key "sort")
    "sf" #'csv-sort-fields
    "sn" #'csv-sort-numeric-fields
    "so" #'csv-toggle-descending
    "t"  #'csv-transpose
    "u"  #'csv-unalign-fields
    "y"  '(:ignore t :which-key yank)
    "yf" #'csv-yank-fields
    "yt" #'csv-yank-as-new-table))
#+end_src
** JSON
#+begin_src emacs-lisp
(use-package json-mode
  :straight (:build t)
  :mode "\\.json$"
  :config
  (add-to-list 'flycheck-disabled-checkers 'json-python-json)
  :general
  (dqv/major-leader-key
    :packages 'json-mode
    :keymaps 'json-mode-map
    "f" #'json-pretty-print-buffer))
#+end_src
* General Programming Languages

** Web programming
[[https://emmet.io/][Emmet]] is a powerful templating engine that can generate through simple CSS-like expression some HTML so you don’t have to write everything by hand.
#+begin_src emacs-lisp
(use-package emmet-mode
  :straight (:build t)
  :defer t
  :hook ((css-mode  . emmet-mode)
         (html-mode . emmet-mode)
         (web-mode  . emmet-mode)
         (sass-mode . emmet-mode)
         (scss-mode . emmet-mode)
         (web-mode  . emmet-mode))
  :config
  (general-define-key
   :keymaps 'emmet-mode-keymap
   "M-RET" #'emmet-expand-yas)
  (dqv/major-leader-key
    :keymaps 'web-mode-map
    :packages '(web-mode emmet-mode)
    "e" '(:ignore t :which-key "emmet")
    "ee" #'emmet-expand-line
    "ep" #'emmet-preview
    "eP" #'emmet-preview-mode
    "ew" #'emmet-wrap-with-markup))
#+end_src

Impatient mode serves web buffers live over HTTP so you can see your editions as you type them.
#+begin_src emacs-lisp
(use-package impatient-mode
  :straight (:build t)
  :defer t)
#+end_src

Web mode is a sort of hybrid major mode that allows editing several languages in the same buffer, mainly HTML, CSS, and Javascript.
#+begin_src emacs-lisp
(use-package web-mode
  :defer t
  :straight (:build t)
  :hook html-mode
  :hook (web-mode . prettier-js-mode)
  :hook (web-mode . lsp-deferred)
  :mode (("\\.phtml\\'"      . web-mode)
         ("\\.tpl\\.php\\'"  . web-mode)
         ("\\.twig\\'"       . web-mode)
         ("\\.xml\\'"        . web-mode)
         ("\\.html\\'"       . web-mode)
         ("\\.htm\\'"        . web-mode)
         ("\\.[gj]sp\\'"     . web-mode)
         ("\\.as[cp]x?\\'"   . web-mode)
         ("\\.eex\\'"        . web-mode)
         ("\\.erb\\'"        . web-mode)
         ("\\.mustache\\'"   . web-mode)
         ("\\.handlebars\\'" . web-mode)
         ("\\.hbs\\'"        . web-mode)
         ("\\.eco\\'"        . web-mode)
         ("\\.ejs\\'"        . web-mode)
         ("\\.svelte\\'"     . web-mode)
         ("\\.ctp\\'"        . web-mode)
         ("\\.djhtml\\'"     . web-mode)
         ("\\.vue\\'"        . web-mode))
  :config
  (csetq web-mode-markup-indent-offset 2
         web-mode-code-indent-offset   2
         web-mode-css-indent-offset    2
         web-mode-style-padding        0
         web-mode-script-padding       0)
  :general
  (dqv/major-leader-key
   :keymaps 'web-mode-map
   :packages 'web-mode
   "="  '(:ignore t :which-key "format")
   "E"  '(:ignore t :which-key "errors")
   "El" #'web-mode-dom-errors-show
   "gb" #'web-mode-element-beginning
   "g"  '(:ignore t :which-key "goto")
   "gc" #'web-mode-element-child
   "gp" #'web-mode-element-parent
   "gs" #'web-mode-element-sibling-next
   "h"  '(:ignore t :which-key "dom")
   "hp" #'web-mode-dom-xpath
   "r"  '(:ignore t :which-key "refactor")
   "j"  '(web-mode-tag-match :which-key "Jump Match")
   "rc" #'web-mode-element-clone
   "rd" #'web-mode-element-vanish
   "rk" #'web-mode-element-kill
   "rr" #'web-mode-element-rename
   "rw" #'web-mode-element-wrap
   "z"  #'web-mode-fold-or-unfold)
  (dqv/major-leader-key
    :keymaps 'web-mode-map
    :packages '(lsp-mode web-mode)
    "l" '(:keymap lsp-command-map :which-key "lsp")))
#+end_src

Auto-completion for ~emmet-mode~, ~html-mode~, and ~web-mode~.
#+begin_src emacs-lisp
(use-package company-web
  :defer t
  :straight (:build t)
  :after (emmet-mode web-mode))
#+end_src

** CSS
Let’s customize a bit the built-in CSS mode.
#+begin_src emacs-lisp
(use-package css-mode
  :defer t
  :straight (:type built-in)
  :hook (css-mode . smartparens-mode)
  :hook (css-mode . lsp-deferred)
  :hook (scss-mode . prettier-js-mode)
  :init
  (put 'css-indent-offset 'safe-local-variable #'integerp)
  :general
  (dqv/major-leader-key
    :keymaps 'css-mode-map
    :packages 'css-mode
    "=" '(:ignore :which-key "format")
    "g" '(:ignore :which-key "goto")))
#+end_src

SCSS is much nicer to use than pure CSS in my opinion, so let’s add a mode for that.
#+begin_src emacs-lisp
(use-package scss-mode
  :straight (:build t)
  :hook (scss-mode . smartparens-mode)
  :hook (scss-mode . lsp-deferred)
  :hook (scss-mode . prettier-js-mode)
  :defer t
  :mode "\\.scss\\'")
#+end_src

And let’s add some autocompletion for CSS.
#+begin_src emacs-lisp
(use-package counsel-css
  :straight (:build t)
  :defer t
  :init
  (cl-loop for (mode-map . mode-hook) in '((css-mode-map  . css-mode-hook)
                                           (scss-mode-map . scss-mode-hook))
           do (add-hook mode-hook #'counsel-css-imenu-setup)
           (dqv/major-leader-key
            :keymaps mode-map
            "gh" #'counsel-css)))
#+end_src

For some reason, although it is built-in, ~less-css-mode~ does not activate when I open ~.less~ files by default. Let’s fix that.
#+begin_src emacs-lisp
(use-package less-css-mode
  :straight  (:type built-in)
  :defer t
  :mode "\\.less\\'"
  :hook (less-css-mode . smartparens-mode)
  :hook (less-css-mode . lsp-deferred)
  :hook (less-css-mode . prettier-js-mode))
#+end_src

** Javascript
javascript-mode is meh at best, while rjsx-mode (Real JSX) is much better: it supports both Javascript and .jsx files for React and Next.JS.
#+begin_src emacs-lisp
(use-package rjsx-mode
  :defer t
  :straight (:build t)
  :after compile
  :mode "\\.[mc]?jsx?\\'"
  :mode "\\.es6\\'"
  :mode "\\.pac\\'"
  :interpreter "node"
  :hook (rjsx-mode . rainbow-delimiters-mode)
  :hook (rjsx-mode . lsp-deferred)
  :hook (rjsx-mode . prettier-js-mode)
  :init
  (add-to-list 'compilation-error-regexp-alist 'node)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(node "^[[:blank:]]*at \\(.*(\\|\\)\\(.+?\\):\\([[:digit:]]+\\):\\([[:digit:]]+\\)"
                      2 3 4))
  :general
  (dqv/major-leader-key
    :keymaps 'rjsx-mode-map
    "rr" #'rjsx-rename-tag-at-point
    "rj" #'rjsx-jump-tag)
  (dqv/evil
    :keymaps 'rjsx-mode-map
    "s-;" #'rjsx-jump-tag
    "s-r" #'rjsx-rename-tag-at-point)
  :config
  (setq js-chain-indent                  t
        js2-basic-offset                 2
        ;; ignore shebangs
        js2-skip-preprocessor-directives t
        ;; Flycheck handles this already
        js2-mode-show-parse-errors       nil
        js2-mode-show-strict-warnings    nil
        ;; conflicting with eslint, Flycheck already handles this
        js2-strict-missing-semi-warning  nil
        js2-highlight-level              3
        js2-idle-timer-delay             0.15))
#+end_src

js2-refactor is an amazing tool for refactoring Javascript code. I mean, look at this! And the video is only from 2013 and it still receives some commits!
#+begin_src emacs-lisp
(use-package js2-refactor
  :defer t
  :straight (:build t)
  :after (js2-mode rjsx-mode)
  :hook (js2-mode . js2-refactor-mode)
  :hook (rjsx-mode . js2-refactor-mode))
#+end_src

Which Emacser prefers the command line over Emacs itself? I don’t. Let’s interact with NPM through Emacs then.
#+begin_src emacs-lisp
(use-package npm-transient
  :defer t
  :straight (npm-transient :build t
                           :type git
                           :host github
                           :repo "Phundrak/npm-transient"))
#+end_src

And finally, here is a formatter for Javascript.
#+begin_src emacs-lisp
(use-package prettier-js
  :defer t
  :straight (:build t)
  :after (rjsx-mode web-mode typescript-mode)
  :hook (rjsx-mode . prettier-js-mode)
  :hook (js-mode . prettier-js-mode)
  :hook (typescript-mode . prettier-js-mode)
  :config
  (setq prettier-js-args '("--trailing-comma" "all" "--bracket-spacing" "true")))
#+end_src

** Typescript
Typescript is a safer alternative to Javascript. Let’s install its major mode then.
#+begin_src emacs-lisp
(use-package typescript-mode
  :defer t
  :straight (:build t)
  :hook (typescript-mode     . rainbow-delimiters-mode)
  :hook (typescript-mode     . lsp-deferred)
  :hook (typescript-mode     . prettier-js-mode)
  :hook (typescript-tsx-mode . rainbow-delimiters-mode)
  :hook (typescript-tsx-mode . lsp-deferred)
  :hook (typescript-tsx-mode . prettier-js-mode)
  :hook (typescript-tsx-mode . eglot-ensure)
  :commands typescript-tsx-mode
  :after flycheck
  :init
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-tsx-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))
  :general
  (dqv/major-leader-key
    :packages 'lsp
    :keymaps '(typescript-mode-map typescript-tsx-mode-map)
    :infix "a"
    ""  '(:keymap lsp-command-map :which-key "lsp")
    "=" '(:ignore t :which-key "format")
    "a" '(:ignore t :which-key "actions"))
  (dqv/major-leader-key
    :packages 'typescript-mode
    :keymaps '(typescript-mode-map typescript-tsx-mode-map)
    "n" '(:keymap npm-mode-command-keymap :which-key "pnpm"))
  :config
  (setq typescript-indent-level 2)
  (with-eval-after-load 'flycheck
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (flycheck-add-mode 'javascript-eslint 'typescript-mode)
    (flycheck-add-mode 'javascript-eslint 'typescript-tsx-mode)
    (flycheck-add-mode 'typescript-tslint 'typescript-tsx-mode))
  (when (fboundp 'web-mode)
    (define-derived-mode typescript-tsx-mode web-mode "TypeScript-TSX"))
  (autoload 'js2-line-break "js2-mode" nil t))
#+end_src

Tide enabled interactivity with Typescript.
#+begin_src emacs-lisp
(use-package tide
  :defer t
  :straight (:build t)
  :hook (tide-mode . tide-hl-identifier-mode)
  :config
  (setq tide-completion-detailed              t
        tide-always-show-documentation        t
        tide-server-may-response-length       524288
        tide-completion-setup-company-backend nil)

  (advice-add #'tide-setup :after #'eldoc-mode)

  :general
  (dqv/major-leader-key
    :keymaps 'tide-mode-map
    "R"   #'tide-restart-server
    "f"   #'tide-format
    "rrs" #'tide-rename-symbol
    "roi" #'tide-organize-imports))
#+end_src

** Golang
#+begin_src emacs-lisp
(use-package go-mode
  :straight (:build t)
  :defer t
  :mode ("\\.go\\'" . go-mode))

;; (lsp-register-custom-settings
;;  '(("gopls.completeUnimported" t t)
;;    ("gopls.staticcheck" t t)))

(defun lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))
(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

(require 'project)

(defun project-find-go-module (dir)
  (when-let ((root (locate-dominating-file dir "go.mod")))
    (cons 'go-module root)))

(cl-defmethod project-root ((project (head go-module)))
  (cdr project))

(add-hook 'project-find-functions #'project-find-go-module)

(add-hook 'go-mode-hook 'eglot-ensure)

(defun eglot-format-buffer-on-save ()
  (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
(add-hook 'go-mode-hook #'eglot-format-buffer-on-save)
#+end_src
* Others
** Beauty Json
#+begin_src emacs-lisp
(defun beautify-json ()
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     "python -mjson.tool" (current-buffer) t)))
#+end_src
** Protobuf
#+begin_src emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto3")
#+end_src
